use once_cell::sync::Lazy;
use std::cell::RefCell;
use std::collections::HashMap;
use std::rc::Rc;
use wasm_bindgen_futures::JsFuture;
use web_sys;

use crate::Error;
use project_core::Result;

/// Centralized manager for serial port objects in the browser environment
///
/// **Note: Documentation generated by AI**
///
/// # Overview
///
/// `SerialPortManager` is a singleton that manages all serial port objects for the
/// Web Serial API implementation. It provides a single point of access to manage
/// multiple connected devices.
///
/// # Design
///
/// This manager uses the singleton pattern to ensure there is exactly one instance
/// throughout the application lifetime. It maintains:
///
/// - A mapping of unique port IDs to `web_sys::SerialPort` objects
/// - Thread-safe access using `once_cell::sync::Lazy`
/// - Non-thread-safe interior mutability using `RefCell` (appropriate for WASM)
///
/// # Usage Pattern
///
/// 1. `WebSerialPort` instances request ports from the manager
/// 2. The manager assigns a unique ID to each port object
/// 3. Each `WebSerialPort` maintains its ID and references the manager
/// 4. Operations on `WebSerialPort` access the port via the manager's registry
///
/// # One-to-One Mapping
///
/// Each `WebSerialPort` instance corresponds to exactly one physical device:
/// - When a port is opened, it's stored in the manager with a unique ID
/// - The `WebSerialPort` holds only the ID, not the port object
/// - All port operations go through the manager lookup
///
/// # WASM Environment Considerations
///
/// - `Lazy` with `RefCell` is used instead of `Mutex` because WASM is single-threaded
/// - This avoids unnecessary synchronization overhead
/// - `Rc<RefCell<>>` is used for interior mutability within the `HashMap`
pub struct SerialPortManager {
    /// Map of unique port IDs to their corresponding SerialPort objects
    /// Wrapped in Rc<RefCell<>> to allow shared mutable access
    ports: HashMap<usize, Rc<RefCell<web_sys::SerialPort>>>,
    /// Counter for generating unique port IDs
    next_id: usize,
}

impl SerialPortManager {
    /// Creates a new SerialPortManager
    ///
    /// **Note: Documentation generated by AI**
    ///
    /// This is called internally when the singleton is first accessed.
    fn new() -> Self {
        Self {
            ports: HashMap::new(),
            next_id: 0,
        }
    }

    /// Initializes the manager by fetching all available ports from the browser
    ///
    /// **Note: Documentation generated by AI**
    ///
    /// # Overview
    ///
    /// This method should be called once at application startup. It performs initialization
    /// of the port registry:
    ///
    /// 1. Fetches all previously permitted ports via `getPorts()`
    /// 2. If no permitted ports exist, automatically shows the port selection dialog via
    ///    `requestPort()` to allow the user to connect their first device
    /// 3. Registers all fetched/requested ports in the manager's registry
    ///
    /// # Behavior
    ///
    /// - If permitted ports exist: Registers them all
    /// - If no permitted ports: Prompts user to select a device, then registers it
    /// - Resets port ID counter to 0
    /// - Clears any existing ports in the registry
    ///
    /// # Returns
    ///
    /// - `Ok(())` if initialization succeeds
    /// - `Err` if the Web Serial API is unavailable or the operation fails
    ///
    /// # Side Effects
    ///
    /// - May show a browser dialog (user interaction) if no ports are permitted
    /// - Clears any existing ports in the registry
    /// - Resets the port ID counter to 0
    /// - Populates the registry with fetched/requested ports
    ///
    /// # Example
    ///
    /// ```ignore
    /// SERIAL_PORT_MANAGER.with_borrow_mut(|manager| {
    ///     manager.initialize().await?
    /// });
    /// // User may see a dialog on first call
    /// ```
    pub async fn initialize(&mut self) -> Result<()> {
        // Clear existing state
        self.ports.clear();
        self.next_id = 0;

        let window = web_sys::window()
            .ok_or_else(|| Error::DeviceNotFound("No window object".to_string()))?;
        let navigator = window.navigator();
        let serial = navigator.serial();

        // Fetch all available ports in a single request
        let promise = serial
            .get_ports()
            .map_err(|e| Error::DeviceNotFound(format!("Failed to get ports: {:?}", e)))?;

        let ports = JsFuture::from(promise)
            .await
            .map_err(|e| Error::DeviceNotFound(format!("Failed to get ports: {:?}", e)))?;

        // Convert JS Array to Vec of ports
        let ports: js_sys::Array = ports
            .dyn_into()
            .map_err(|_| Error::DeviceNotFound("Failed to convert ports array".to_string()))?;

        // If no ports are permitted, request one from the user
        if ports.length() == 0 {
            // Show the port selection dialog to the user
            let options = web_sys::SerialPortRequestOptions::new();
            let promise = serial
                .request_port(&options)
                .map_err(|e| Error::DeviceNotFound(format!("Failed to request port: {:?}", e)))?;

            let port = JsFuture::from(promise)
                .await
                .map_err(|e| Error::DeviceNotFound(format!("User cancelled or error: {:?}", e)))?
                .dyn_into::<web_sys::SerialPort>()
                .map_err(|_| Error::DeviceNotFound("Failed to cast to SerialPort".to_string()))?;

            // Register the user-selected port
            let id = self.next_id;
            self.next_id = self.next_id.wrapping_add(1);
            self.ports.insert(id, Rc::new(RefCell::new(port)));
        } else {
            // Register all fetched permitted ports
            for i in 0..ports.length() {
                if let Some(port) = ports.get(i).dyn_ref::<web_sys::SerialPort>() {
                    let id = self.next_id;
                    self.next_id = self.next_id.wrapping_add(1);
                    self.ports.insert(id, Rc::new(RefCell::new(port.clone())));
                }
            }
        }

        Ok(())
    }

    /// Registers a new port and returns its unique ID
    ///
    /// **Note: Documentation generated by AI**
    ///
    /// # Parameters
    ///
    /// - `port`: The `web_sys::SerialPort` object to register
    ///
    /// # Returns
    ///
    /// A unique ID that can be used to refer to this port in future operations
    ///
    /// # Usage
    ///
    /// This method is used when a new port is opened via `requestPort()` after initialization.
    /// For pre-initialized ports from `initialize()`, use `list_registered_ports()` instead.
    ///
    /// # Panics
    ///
    /// Never panics in normal operation. The ID counter may overflow theoretically,
    /// but this is extremely unlikely in practice (would require opening ~2^64 ports).
    fn register_port(&mut self, port: web_sys::SerialPort) -> usize {
        let id = self.next_id;
        self.next_id = self.next_id.wrapping_add(1);
        self.ports.insert(id, Rc::new(RefCell::new(port)));
        id
    }

    /// Retrieves a reference to a registered port by ID
    ///
    /// **Note: Documentation generated by AI**
    ///
    /// # Parameters
    ///
    /// - `port_id`: The ID returned by `register_port()`
    ///
    /// # Returns
    ///
    /// `Some(Rc<RefCell<web_sys::SerialPort>>)` if the port is registered,
    /// `None` if the ID is invalid or the port was previously unregistered
    fn get_port(&self, port_id: usize) -> Option<Rc<RefCell<web_sys::SerialPort>>> {
        self.ports.get(&port_id).cloned()
    }

    /// Unregisters a port by ID
    ///
    /// **Note: Documentation generated by AI**
    ///
    /// # Parameters
    ///
    /// - `port_id`: The ID returned by `register_port()`
    ///
    /// # Returns
    ///
    /// `Some(Rc<RefCell<web_sys::SerialPort>>)` if the port was found and removed,
    /// `None` if the ID was invalid
    fn unregister_port(&mut self, port_id: usize) -> Option<Rc<RefCell<web_sys::SerialPort>>> {
        self.ports.remove(&port_id)
    }

    /// Returns a list of all registered port IDs
    ///
    /// **Note: Documentation generated by AI**
    ///
    /// # Returns
    ///
    /// A vector of all port IDs currently registered in the manager
    ///
    /// # Usage
    ///
    /// Use this method after `initialize()` to discover all available ports
    /// that were fetched at startup.
    ///
    /// # Example
    ///
    /// ```ignore
    /// let port_ids = SERIAL_PORT_MANAGER.borrow().list_registered_ports();
    /// for id in port_ids {
    ///     // Use the port with this ID
    /// }
    /// ```
    pub fn list_registered_ports(&self) -> Vec<usize> {
        self.ports.keys().copied().collect()
    }

    /// Requests a new port from the user via browser dialog and registers it
    ///
    /// **Note: Documentation generated by AI**
    ///
    /// # Overview
    ///
    /// This method is the **only way** to request new ports from the user. It ensures
    /// that all port requests go through the manager for centralized tracking.
    ///
    /// # Behavior
    ///
    /// 1. Calls `navigator.serial.requestPort()` to show the browser's port selection dialog
    /// 2. Waits for the user to select a port
    /// 3. If a port is selected, registers it and returns the ID
    /// 4. If the user cancels, returns an error
    ///
    /// # Returns
    ///
    /// - `Ok(usize)` - The ID of the newly registered port
    /// - `Err` - If the user cancels, the API fails, or the port cannot be registered
    ///
    /// # Side Effects
    ///
    /// - Shows a browser dialog (user interaction required)
    /// - Increments the port ID counter
    /// - Adds a new port to the registry
    ///
    /// # Usage
    ///
    /// This should be called after `initialize()` if no existing ports are available
    /// and the user needs to add a new device.
    pub async fn request_port(&mut self) -> Result<usize> {
        let window = web_sys::window()
            .ok_or_else(|| Error::DeviceNotFound("No window object".to_string()))?;
        let navigator = window.navigator();
        let serial = navigator.serial();

        let options = web_sys::SerialPortRequestOptions::new();
        let promise = serial
            .request_port(&options)
            .map_err(|e| Error::OpenError(format!("Failed to request port: {:?}", e)))?;

        let port = JsFuture::from(promise)
            .await
            .map_err(|e| Error::OpenError(format!("User cancelled or error: {:?}", e)))?
            .dyn_into::<web_sys::SerialPort>()
            .map_err(|_| Error::OpenError("Failed to cast to SerialPort".to_string()))?;

        let id = self.register_port(port);
        Ok(id)
    }
}

/// Singleton instance of SerialPortManager
///
/// **Note: Documentation generated by AI**
///
/// # Guarantees
///
/// - Exactly one instance exists for the entire application
/// - Created lazily on first access
/// - Thread-safe initialization (handled by `once_cell`)
/// - Safe for mutable access from single-threaded WASM code
///
/// # Access Pattern
///
/// ```ignore
/// SERIAL_PORT_MANAGER.with_borrow_mut(|manager| {
///     let id = manager.register_port(port);
/// });
/// ```
pub static SERIAL_PORT_MANAGER: Lazy<RefCell<SerialPortManager>> =
    Lazy::new(|| RefCell::new(SerialPortManager::new()));
