use std::cell::RefCell;
use std::collections::HashMap;
use std::rc::Rc;
use wasm_bindgen::JsCast;
use wasm_bindgen_futures::JsFuture;
use web_sys::{self, SerialPort};

use project_core;

/// Centralized manager for serial port objects in the browser environment
///
/// **Note: Documentation generated by AI**
///
/// # Overview
///
/// `SerialPortManager` is a singleton that manages all serial port objects for the
/// Web Serial API implementation. It provides a single point of access to manage
/// multiple connected devices.
///
/// # Design
///
/// This manager uses the singleton pattern to ensure there is exactly one instance
/// throughout the application lifetime. It maintains:
///
/// - A mapping of unique port IDs to `SerialPort` objects
/// - Thread-safe access using `once_cell::sync::Lazy`
/// - Non-thread-safe interior mutability using `RefCell` (appropriate for WASM)
///
/// # Usage Pattern
///
/// 1. `WebSerialPort` instances request ports from the manager
/// 2. The manager assigns a unique ID to each port object
/// 3. Each `WebSerialPort` maintains its ID and references the manager
/// 4. Operations on `WebSerialPort` access the port via the manager's registry
///
/// # One-to-One Mapping
///
/// Each `WebSerialPort` instance corresponds to exactly one physical device:
/// - When a port is opened, it's stored in the manager with a unique ID
/// - The `WebSerialPort` holds only the ID, not the port object
/// - All port operations go through the manager lookup
///
/// # WASM Environment Considerations
///
/// - `Lazy` with `RefCell` is used instead of `Mutex` because WASM is single-threaded
/// - This avoids unnecessary synchronization overhead
/// - `Rc<RefCell<>>` is used for interior mutability within the `HashMap`
pub struct SerialPortManager {
    /// Map of unique port IDs to their corresponding SerialPort objects
    /// Wrapped in Rc<RefCell<>> to allow shared mutable access
    ports: HashMap<usize, Rc<RefCell<SerialPort>>>,
    /// Counter for generating unique port IDs
    next_id: usize,
}

impl SerialPortManager {
    /// Creates a new SerialPortManager
    ///
    /// **Note: Documentation generated by AI**
    ///
    /// This is called internally when the singleton is first accessed.
    fn new() -> Self {
        Self {
            ports: HashMap::new(),
            next_id: 0,
        }
    }

    /// Initializes the manager by fetching all available ports from the browser
    ///
    /// **Note: Documentation generated by AI**
    ///
    /// # Overview
    ///
    /// This method should be called once at application startup. It performs initialization
    /// of the port registry:
    ///
    /// 1. Fetches all previously permitted ports via `getPorts()`
    /// 2. If no permitted ports exist, automatically shows the port selection dialog via
    ///    `requestPort()` to allow the user to connect their first device
    /// 3. Registers all fetched/requested ports in the manager's registry
    ///
    /// # Behavior
    ///
    /// - If permitted ports exist: Registers them all
    /// - If no permitted ports: Prompts user to select a device, then registers it
    /// - Resets port ID counter to 0
    /// - Clears any existing ports in the registry
    ///
    /// # Returns
    ///
    /// - `Ok(())` if initialization succeeds
    /// - `Err` if the Web Serial API is unavailable or the operation fails
    ///
    /// # Side Effects
    ///
    /// - May show a browser dialog (user interaction) if no ports are permitted
    /// - Clears any existing ports in the registry
    /// - Resets the port ID counter to 0
    /// - Populates the registry with fetched/requested ports
    ///
    /// # Example
    ///
    /// ```ignore
    /// SERIAL_PORT_MANAGER.with_borrow_mut(|manager| {
    ///     manager.initialize().await?
    /// });
    /// Registers a new port and returns its unique ID
    ///
    /// **Note: Documentation generated by AI**
    ///
    /// # Parameters
    ///
    /// - `port`: The `SerialPort` object to register
    ///
    /// # Returns
    ///
    /// A unique ID that can be used to refer to this port in future operations
    ///
    /// # Usage
    ///
    /// This method is used when a new port is acquired via `request_port()`.
    /// All ports must be registered with the manager to be used.
    ///
    /// # Panics
    ///
    /// Never panics in normal operation. The ID counter may overflow theoretically,
    /// but this is extremely unlikely in practice (would require opening ~2^64 ports).
    pub(crate) fn register_port(&mut self, port: SerialPort) -> usize {
        let id = self.next_id;
        self.next_id = self.next_id.wrapping_add(1);
        self.ports.insert(id, Rc::new(RefCell::new(port)));
        id
    }

    /// Retrieves a reference to a registered port by ID
    ///
    /// **Note: Documentation generated by AI**
    ///
    /// # Parameters
    ///
    /// - `port_id`: The ID returned by `register_port()`
    ///
    /// # Returns
    ///
    /// `Some(Rc<RefCell<SerialPort>>)` if the port is registered,
    /// `None` if the ID is invalid or the port was previously unregistered
    pub(crate) fn get_port(&self, port_id: usize) -> Option<Rc<RefCell<SerialPort>>> {
        self.ports.get(&port_id).cloned()
    }

    /// Unregisters a port by ID
    ///
    /// **Note: Documentation generated by AI**
    ///
    /// # Parameters
    ///
    /// - `port_id`: The ID returned by `register_port()`
    ///
    /// # Returns
    ///
    /// `Some(Rc<RefCell<SerialPort>>)` if the port was found and removed,
    /// `None` if the ID was invalid
    pub(crate) fn unregister_port(&mut self, port_id: usize) -> Option<Rc<RefCell<SerialPort>>> {
        self.ports.remove(&port_id)
    }

    /// Returns a list of all registered port IDs
    ///
    /// **Note: Documentation generated by AI**
    ///
    /// # Returns
    ///
    /// A vector of all port IDs currently registered in the manager
    ///
    /// # Usage
    ///
    /// Use this method to discover all ports that have been registered via `request_port()`.
    ///
    /// # Example
    ///
    /// ```ignore
    /// let port_ids = SERIAL_PORT_MANAGER.borrow().list_registered_ports();
    /// for id in port_ids {
    ///     // Use the port with this ID
    /// }
    /// ```
    pub fn list_registered_ports(&self) -> Vec<usize> {
        self.ports.keys().copied().collect()
    }

    /// Requests a new port from the user via browser dialog and registers it
    ///
    /// **Note: Documentation generated by AI**
    ///
    /// # Overview
    ///
    /// This method is the **only way** to request new ports from the user. It ensures
    /// that all port requests go through the manager for centralized tracking.
    ///
    /// # Behavior
    ///
    /// 1. Calls `navigator.serial.requestPort()` to show the browser's port selection dialog
    /// 2. Waits for the user to select a port
    /// 3. If a port is selected, registers it and returns the ID
    /// 4. If the user cancels, returns an error
    ///
    /// # Returns
    ///
    /// - `Ok(usize)` - The ID of the newly registered port
    /// - `Err` - If the user cancels, the API fails, or the port cannot be registered
    ///
    /// # Side Effects
    ///
    /// - Shows a browser dialog (user interaction required)
    /// - Increments the port ID counter
    /// - Adds a new port to the registry
    ///
    /// # Usage
    ///
    /// This should be called after `initialize()` if no existing ports are available
    /// and the user needs to add a new device.
    pub async fn request_port(&mut self) -> project_core::Result<usize> {
        let window = web_sys::window()
            .ok_or_else(|| project_core::Error::DeviceNotFound("No window object".to_string()))?;
        let navigator = window.navigator();
        let serial = navigator.serial();

        let promise = serial.request_port();

        let port = JsFuture::from(promise)
            .await
            .map_err(|_| project_core::Error::OpenError("User cancelled or error".to_string()))?
            .dyn_into::<SerialPort>()
            .map_err(|_| {
                project_core::Error::OpenError("Failed to cast to SerialPort".to_string())
            })?;

        let id = self.register_port(port);
        Ok(id)
    }
}

thread_local! {
    /// Singleton instance of SerialPortManager
    ///
    /// **Note: Documentation generated by AI**
    ///
    /// # Guarantees
    ///
    /// - Exactly one instance exists for the entire application
    /// - Created lazily on first access
    /// - Thread-safe initialization (handled by `once_cell`)
    /// - Safe for mutable access from single-threaded WASM code
    ///
    /// # Access Pattern
    ///
    /// ```ignore
    /// SERIAL_PORT_MANAGER.with_borrow_mut(|manager| {
    ///     let id = manager.register_port(port);
    /// });
    /// ```
    pub static SERIAL_PORT_MANAGER: RefCell<SerialPortManager> =
        RefCell::new(SerialPortManager::new());
}
