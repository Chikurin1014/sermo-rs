use async_trait::async_trait;
use wasm_bindgen::JsCast;
use wasm_bindgen_futures::JsFuture;
use web_sys;

use project_core;

use crate::serialport_manager::SERIAL_PORT_MANAGER;

/// Web implementation of SerialPort using Web Serial API
///
/// **Note: Documentation generated by AI**
///
/// # Overview
///
/// `WebSerialPort` represents a single physical serial port device in the browser.
/// Each instance corresponds to exactly one connected device and manages
/// communication with that device through the Web Serial API.
///
/// # Architecture
///
/// Unlike the desktop implementation which owns the `SerialPort` object directly,
/// `WebSerialPort` delegates port storage to `SerialPortManager`:
///
/// 1. When `open()` is called, the port object is registered with the manager
/// 2. The manager returns a unique ID for this port
/// 3. `WebSerialPort` stores only the ID
/// 4. All operations access the port through the manager lookup
/// 5. When closed, the port is unregistered from the manager
///
/// This design enables:
/// - Centralized port lifecycle management
/// - Clear separation between device representation and port management
/// - Easier debugging and monitoring of all active ports
///
/// # One-to-One Mapping
///
/// Each `WebSerialPort` instance maps to exactly one physical device:
/// - Multiple `WebSerialPort` instances can exist but each has a different ID
/// - A single port cannot be opened in multiple `WebSerialPort` instances simultaneously
/// - Port isolation is managed by the OS/browser
///
/// # Web Serial API Constraints
///
/// Web Serial API has the following constraints due to browser security model:
///
/// - **HTTPS Required**: Only works over HTTPS or localhost
/// - **User Interaction Required**: Port access always requires explicit user permission
/// - **No Port Names**: Unlike desktop versions, port names like "COM1" or "/dev/ttyUSB0"
///   are not available. Instead, devices are identified by USB Vendor ID/Product ID
///
/// # Workflow
///
/// 1. **First Connection**: When `open()` is called, `requestPort()` is invoked and the
///    browser displays a port selection dialog. When the user selects a port, it becomes
///    "permitted" and is remembered by the browser.
///
/// 2. **Subsequent Connections**: `getPorts()` can retrieve the list of previously
///    permitted ports. If multiple ports are permitted, the app should provide UI for
///    the user to select among them.
///
/// # Notes
///
/// - `read()` and `write()` are stub implementations. Full implementation requires proper
///   handling of Web Streams API `ReadableStream`/`WritableStream`
/// - Page reload preserves permissions, but a different origin requires re-permission
pub struct WebSerialPort {
    /// Unique identifier for this port in the SerialPortManager
    /// None when the port is not open
    port_id: Option<usize>,
    config: project_core::PortInfo,
}

impl WebSerialPort {
    /// Creates a new WebSerialPort without a port ID
    ///
    /// **Note: Documentation generated by AI**
    ///
    /// # Usage
    ///
    /// After creating an instance, you must obtain a port ID before calling `open()`:
    ///
    /// 1. Use `SerialPortManager::initialize()` to get pre-fetched ports at startup
    /// 2. Or use `SerialPortManager::request_port()` to request a new port from the user
    /// 3. Then set the port ID before calling `open()`
    ///
    /// # Example
    ///
    /// ```ignore
    /// // After manager initialization
    /// let port_ids = SERIAL_PORT_MANAGER.borrow().list_registered_ports();
    /// let mut serial_port = WebSerialPort::new(config);
    /// serial_port.port_id = Some(port_ids[0]);  // Set the port ID
    /// serial_port.open().await?;
    /// ```
    pub fn new(config: project_core::PortInfo) -> Self {
        Self {
            port_id: None,
            config,
        }
    }

    /// Sets the port ID for this WebSerialPort
    ///
    /// **Note: Documentation generated by AI**
    ///
    /// # Parameters
    ///
    /// - `id`: A port ID obtained from `SerialPortManager`
    ///
    /// # Panics
    ///
    /// Never panics. Invalid IDs will result in an error when `open()` is called.
    pub fn set_port_id(&mut self, id: usize) {
        self.port_id = Some(id);
    }

    /// Returns a list of all currently registered port IDs
    ///
    /// **Note: Documentation generated by AI**
    ///
    /// # Returns
    ///
    /// A vector of port IDs that are currently registered in the manager
    ///
    /// # Usage
    ///
    /// Use this to discover which ports are available for use:
    ///
    /// ```ignore
    /// let port_ids = WebSerialPort::list_registered_ports();
    /// for id in port_ids {
    ///     let mut port = WebSerialPort::new(config);
    ///     port.set_port_id(id);
    ///     port.open().await?;
    /// }
    /// ```
    pub fn list_registered_ports() -> Vec<usize> {
        SERIAL_PORT_MANAGER.with(|manager| manager.borrow().list_registered_ports())
    }
}

impl Default for WebSerialPort {
    /// Creates a new WebSerialPort with default configuration
    ///
    /// **Note: Documentation generated by AI**
    fn default() -> Self {
        Self::new(project_core::PortInfo::default())
    }
}

impl project_core::SerialPortConfig for WebSerialPort {
    fn with_port(mut self, port: String) -> Self {
        self.config = self.config.with_port(port);
        self
    }

    fn with_baud_rate(mut self, baud_rate: u32) -> Self {
        self.config = self.config.with_baud_rate(baud_rate);
        self
    }

    fn with_data_bits(mut self, data_bits: u8) -> Self {
        self.config = self.config.with_data_bits(data_bits);
        self
    }

    fn with_stop_bits(mut self, stop_bits: u8) -> Self {
        self.config = self.config.with_stop_bits(stop_bits);
        self
    }
}

#[async_trait(?Send)]
impl project_core::SerialPort for WebSerialPort {
    /// Opens the serial port
    ///
    /// **Note: Documentation generated by AI**
    ///
    /// # Behavior
    ///
    /// 1. Looks up the port in `SerialPortManager` using the stored ID
    /// 2. Configures the port (baud rate, data bits, stop bits)
    /// 3. Opens the port via Web Serial API
    /// 4. Stores the port ID for future operations
    ///
    /// # Port Acquisition
    ///
    /// This method does NOT directly request new ports. Instead:
    /// - It requires the port ID to be set before calling this method
    /// - Port IDs come from either:
    ///   - `SerialPortManager::initialize()` - pre-fetched ports at startup
    ///   - `SerialPortManager::request_port()` - user-requested new port
    ///
    /// # Errors
    ///
    /// - If port ID is not set
    /// - If the port is not found in the manager
    /// - If port configuration fails
    /// - If the port cannot be opened
    ///
    /// # Panics
    ///
    /// Never panics in normal operation
    async fn open(&mut self) -> project_core::Result<()> {
        // If port ID is not set, request a new port from the user
        if self.port_id.is_none() {
            // Request a new port via the manager
            let port_id = request_port_from_manager().await?;
            self.port_id = Some(port_id);
        }

        let port_id = self.port_id.unwrap();

        // Get the port from the manager
        let port_rc = SERIAL_PORT_MANAGER
            .with(|manager| manager.borrow().get_port(port_id))
            .ok_or_else(|| {
                project_core::Error::OpenError("Port not found in manager".to_string())
            })?;

        // Configure and open the port
        #[allow(unused_mut)]
        let mut options = web_sys::SerialOptions::new(self.config.baud_rate);
        options.set_data_bits(self.config.data_bits);
        options.set_stop_bits(self.config.stop_bits);

        let promise = {
            let port = port_rc.borrow();
            port.open(&options)
        };

        JsFuture::from(promise)
            .await
            .map_err(|_| project_core::Error::OpenError("Failed to open port".to_string()))?;

        Ok(())
    }

    /// Closes the serial port
    ///
    /// **Note: Documentation generated by AI**
    ///
    /// # Behavior
    ///
    /// 1. Looks up the port in `SerialPortManager` using the stored ID
    /// 2. Closes the port if it is open
    /// 3. Unregisters the port from the manager
    /// 4. Clears the stored port ID
    ///
    /// # Side Effects
    ///
    /// - Sets `self.port_id` to None
    /// - Removes the port from the manager
    async fn close(&mut self) -> project_core::Result<()> {
        if let Some(id) = self.port_id {
            let port_opt =
                SERIAL_PORT_MANAGER.with(|manager| manager.borrow_mut().unregister_port(id));

            if let Some(port_rc) = port_opt {
                let port = port_rc.borrow();
                let promise = port.close();

                JsFuture::from(promise).await.map_err(|_| {
                    project_core::Error::OpenError("Failed to close port".to_string())
                })?;
            }

            self.port_id = None;
        }

        Ok(())
    }

    /// Reads data from the serial port
    ///
    /// **Note: Documentation generated by AI**
    ///
    /// # Notes
    ///
    /// This is a stub implementation. A full implementation would require:
    ///
    /// 1. Look up the port from the manager using the stored ID
    /// 2. Get ReadableStream via `port.readable()`
    /// 3. Get a Reader via `getReader()`
    /// 4. Asynchronously read data chunks via `read()`
    /// 5. Copy data to buffer
    /// 6. Release the reader
    ///
    /// Due to complex Web Streams API usage requirements, this currently returns an error.
    async fn read(&mut self, _buf: &mut [u8]) -> project_core::Result<usize> {
        if self.port_id.is_none() {
            return Err(project_core::Error::ReadError("Port not open".to_string()));
        }

        Err(project_core::Error::ReadError(
            "Read not fully implemented for web".to_string(),
        ))
    }

    /// Writes data to the serial port
    ///
    /// **Note: Documentation generated by AI**
    ///
    /// # Notes
    ///
    /// This is a stub implementation. A full implementation would require:
    ///
    /// 1. Look up the port from the manager using the stored ID
    /// 2. Get WritableStream via `port.writable()`
    /// 3. Get a Writer via `getWriter()`
    /// 4. Asynchronously write data chunks via `write()`
    /// 5. Release the writer
    ///
    /// Due to complex Web Streams API usage requirements, this currently returns an error.
    async fn write(&mut self, _buf: &[u8]) -> project_core::Result<usize> {
        if self.port_id.is_none() {
            return Err(project_core::Error::WriteError("Port not open".to_string()));
        }

        Err(project_core::Error::WriteError(
            "Write not fully implemented for web".to_string(),
        ))
    }

    /// Checks if the port is open
    ///
    /// **Note: Documentation generated by AI**
    ///
    /// # Returns
    ///
    /// `true` if the port is open (has a valid ID in the manager), `false` otherwise
    fn is_open(&self) -> bool {
        self.port_id.is_some()
    }

    /// Retrieves the list of serial ports previously permitted by the user
    ///
    /// **Note: Documentation generated by AI**
    ///
    /// # Behavior
    ///
    /// - Calls `navigator.serial.getPorts()`
    /// - Returns only ports that the user has previously permitted
    /// - Returns an empty list on first access or if no ports are permitted yet
    ///
    /// # Notes
    ///
    /// - Web Serial API does not provide port names (like COM1, /dev/ttyUSB0)
    /// - Generic names like "Serial Port 0", "Serial Port 1" are used instead
    /// - Actual device identification requires USB Vendor ID/Product ID
    ///   (not currently implemented)
    async fn list_ports() -> project_core::Result<Vec<project_core::PortInfo>> {
        let window = web_sys::window()
            .ok_or_else(|| project_core::Error::DeviceNotFound("No window object".to_string()))?;
        let navigator = window.navigator();
        let serial = navigator.serial();

        let promise = serial.get_ports();

        let ports = JsFuture::from(promise)
            .await
            .map_err(|_| project_core::Error::DeviceNotFound("Failed to get ports".to_string()))?;

        let ports: js_sys::Array = ports.dyn_into().map_err(|_| {
            project_core::Error::DeviceNotFound("Failed to convert ports".to_string())
        })?;
        let mut result = Vec::new();
        for i in 0..ports.length() {
            if let Some(_port) = ports.get(i).dyn_ref::<web_sys::SerialPort>() {
                result.push(project_core::PortInfo::new(
                    format!("Serial Port {}", i),
                    9600,
                    8,
                    1,
                ));
            }
        }

        Ok(result)
    }
}

/// Helper function to request a new port from the manager
///
/// This function is used internally when a WebSerialPort needs to request
/// a new port because none was pre-configured.
async fn request_port_from_manager() -> project_core::Result<usize> {
    // Create a mutable borrow outside the with() to avoid lifetime issues
    // We need to call request_port which is async
    let window = web_sys::window()
        .ok_or_else(|| project_core::Error::DeviceNotFound("No window object".to_string()))?;
    let navigator = window.navigator();
    let serial = navigator.serial();

    let promise = serial.request_port();

    let port = JsFuture::from(promise)
        .await
        .map_err(|_| project_core::Error::OpenError("User cancelled or error".to_string()))?
        .dyn_into::<web_sys::SerialPort>()
        .map_err(|_| {
            project_core::Error::OpenError("Failed to cast to SerialPort".to_string())
        })?;

    // Register the port with the manager and return the ID
    let port_id = SERIAL_PORT_MANAGER.with(|manager| {
        manager.borrow_mut().register_port(port)
    });

    Ok(port_id)
}
